import copy
import io  # for visualisation purposes (Optional)
import os  # for visualisation purposes (Optional)
import random

import folium  # for visualisation purposes (Optional)
import numpy as np
import pandas as pd
from folium import IFrame  # for visualisation purposes (Optional)
from PIL import Image  # for visualisation purposes (Optional)
from selenium import webdriver  # for visualisation purposes (Optional)
from selenium.webdriver.chrome.options import (
    Options,  # for visualisation purposes (Optional)
)
from selenium.webdriver.chrome.service import (
    Service,  # for visualisation purposes (Optional)
)


def get_data():
    """Get the data for the problem"""
    # Define the cost matrix
    connections_cost = np.array([
    # S      A1      A2      A3      A4      A5      A6      B1      B2      B3      B4      B5      B6      B7      B8      B9      B10     B11     C1      C2      C3      C4      C5      C6      C7      C8      C9      C10     C11     C12     C13     D1      D2      D3      D4      D5      D6      D7      D8      D9      D10     D11     D12     D13     E1      E2      E3      E
    [np.inf, 1.3,    1.9,    2.5,    3.2,    np.inf, np.inf, 0.2,    93.9,   1.7,    2.4,    3.1,    3.8,    4.5,    5.3,    6,      6.7,    7.4,    1.1,    1.4,    2.0,    2.6,    3.3,    4.0,    4.8,    5.5,    6.2,    6.9,    7.6,    8.3,    np.inf, 2.2,    2.4,    2.7,    3.3,    3.8,    4.5,    5.1,    5.8,    6.5,    7.2,    7.9,    8.6,    9.3,    7.5,    8.3,    9.0,    9.9],  # S
    [1.3,    np.inf, 0.7,    1.4,    2.1,    np.inf, np.inf, 1.2,    99.3,   1.2,    1.7,    2.4,    3,      3.7,    np.inf, np.inf, np.inf, np.inf, 2.1,    2.0,    2.1,    2.5,    2.9,    3.5,    4.1,    4.8,    5.4,    6.1,    6.8,    7.5,    np.inf, 3.1,    3.0,    3.1,    3.3,    3.7,    4.2,    4.6,    5.3,    5.9,    6.6,    7.2,    7.9,    8.6,    7.1,    7.7,    8.4,    9.1],  # A1
    [1.9,    0.7,    np.inf, 0.7,    1.4,    np.inf, np.inf, 1.7,    122.3,  1,      1.2,    1.7,    2.4,    3,      np.inf, np.inf, np.inf, np.inf, 2.5,    2.1,    2.0,    2.1,    2.5,    3.0,    3.5,    4.1,    4.8,    5.4,    np.inf, np.inf, np.inf, 3.3,    3.1,    3.0,    3.1,    3.3,    3.7,    4.0,    4.7,    5.3,    5.9,    6.6,    7.2,    7.9,    6.5,    7.0,    7.7,    8.5],  # A2
    [2.5,    1.4,    0.7,    np.inf, 0.7,    np.inf, np.inf, 2.4,    167.5,  1.2,    1,      1.2,    1.7,    np.inf, np.inf, np.inf, np.inf, np.inf, 2.9,    2.4,    2.1,    2.0,    2.1,    2.4,    2.9,    3.5,    4.1,    np.inf, np.inf, np.inf, np.inf, 3.7,    3.3,    3.1,    3.0,    3.1,    3.3,    3.5,    4.2,    4.7,    5.2,    5.9,    np.inf, np.inf, 5.9,    6.4,    7.1,    np.inf],  # A3
    [3.2,    2.1,    1.4,    0.7,    np.inf, np.inf, np.inf, 3.0,    23.6,   1.7,    1.2,    1.0,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, 3.5,	 2.9,    2.5,    2.1,    2.0,    2.1,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, 4.2,    3.7,    3.3,    3.1,    3.0,    3.1,    3.2,    4.1,    4.6,    5.2,    5.9,    6.3,    6.9,    7.2,    7.9,    8.1,    8.4], #A4
    [np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, 0.7,    np.inf, np.inf, np.inf, 2.4,    1.7,    1.2,    1.0,    1.2,    1.7,    2.4,    np.inf, np.inf, 4.1,    3.5,    2.9,    2.5,    2.1,    2.0,    2.1,    2.5,    2.9,    3.5,    np.inf, 5.9,    5.3,    4.7,    4.2,    3.7,    3.3,    2.9,    3.0,    3.1,    3.3,    3.7,    4.2,    4.7,    4.3,    4.5,    5.0,    5.3,    5.2], # A5
    [np.inf, np.inf, np.inf, np.inf, np.inf, 0.7,    np.inf, np.inf, np.inf, np.inf, np.inf, 3.0,    2.4,    1.7,    1.2,    1.0,    1.2,    np.inf, 6.1,    5.4,    4.8,    4.1,    3.5,    3.0,    2.5,    2.1,    2.0,    2.1,    2.5,    np.inf, np.inf, 6.5,    5.9,    5.3,    4.7,    4.2,    3.7,    3.1,    3.1,    3.0,    3.1,    3.3,    3.7,    np.inf, 4.1,    4.2,    4.6,    np.inf], # A6
    [0.2,    1.2,    1.7,    2.4,    3.0,    np.inf, np.inf, np.inf, 71.7,   1.4,    2.2,    2.9,    3.6,    4.3,    5.0,    5.8,    6.5,    7.2,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    5.2,    5.9,    6.6,    7.3,    8.1,    np.inf, 2.0,    2.1,    2.5,    3.0,    3.5,    4.2,    4.7,    5.5,    6.2,    6.9,    7.6,    8.3,    9.0,    7.3,    7.9,    8.7,    9.6], # B1
    [9.4,    9.9,    12.2,   16.8,   23.6,   np.inf, np.inf, 7.2,    np.inf, 7.2,    14.5,   21.6,   28.8,   36.1,   43.3,   50.4,   57.8,   64.9,   12.4,   10.0,   12.3,   17.6,   24.0,   30.7,   37.6,   44.8,   51.9,   59.0,   66.3,   73.4,   np.inf, 21.2,   20.0,   21.3,   24.7,   29.6,   35.5,   40.8,   48.3,   55.1,   61.9,   69.0,   75.9,   82.2,   np.inf, 72.5,   79.5,   88.7], # B2
    [1.7,    1.2,    1.0,    1.2,    1.7,    np.inf, np.inf, 1.4,    7.1,    np.inf, 0.7,    1.4,    2.2,    2.9,    3.6,    4.3,    5.1,    5.8,    1.8,    1.2,    1.0,    1.3,    1.8,    2.4,    3.1,    3.8,    4.5,    5.2,    5.9,    6.6,    np.inf, 2.5,    2.1,    2.0,    2.2,    2.5,    3.0,    3.4,    4.2,    4.9,    5.5,    6.2,    6.9,    7.6,    6.0,    6.6,    7.3,    8.1], # B3
    [2.4,    1.7,    1.2,    1.0,    1.2,    np.inf, np.inf, 2.2,    14.5,   0.7,    np.inf, 0.7,    1.4,    2.2,    2.9,    3.6,    4.3,    5.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    5.2,    5.9,    np.inf, 3.0,    2.5,    2.1,    2.0,    2.1,    2.5,    2.8,    3.6,    4.2,    4.8,    5.5,    6.2,    6.9,    5.3,    5.9,    6.6,    7.5], # B4
    [3.1,    2.4,    1.7,    1.2,    1.0,    2.4,    3.0,    2.9,    21.6,   1.4,    0.7,    np.inf, 0.7,    1.4,    2.2,    2.9,    3.6,    4.3,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    5.2,    np.inf, 3.6,    3.0,    2.5,    2.1,    2.0,    2.1,    2.3,    3.0,    3.5,    4.2,    4.8,    5.5,    6.2,    4.7,    5.3,    6.0,    6.7], # B5
    [3.8,    3.0,    2.4,    1.7,    np.inf, 1.7,    2.4,    3.6,    28.8,   2.2,    1.4,    0.7,    np.inf, 0.7,    1.4,    2.2,    2.9,    3.6,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    np.inf, 4.2,    3.5,    3.0,    2.5,    2.1,    2.0,    1.9,    2.5,    3.0,    3.6,    4.2,    4.8,    5.5,    4.2,    4.7,    5.4,    6.1], # B6
    [4.5,    3.7,    3.0,    np.inf, np.inf, 1.2,    1.7,    4.3,    36.1,   2.9,    2.2,    1.4,    0.7,    np.inf, 0.7,    1.4,    2.2,    2.9,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.3,    1.8,    2.4,    3.1,    3.8,    np.inf, 4.8,    4.2,    3.6,    3.0,    2.5,    2.1,    1.8,    2.1,    2.5,    3.0,    3.6,    4.2,    4.8,    3.7,    4.1,    4.8,    5.4], # B7
    [5.3,    np.inf, np.inf, np.inf, np.inf, 1.0,    1.2,    5.0,    43.3,   3.6,    2.9,    2.2,    1.4,    0.7,    np.inf, 0.7,    1.4,    2.2,    5.2,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    np.inf, 5.5,    4.8,    4.2,    3.5,    3.0,    2.4,    1.9,    2.0,    2.1,    2.5,    3.0,    3.6,    4.2,    3.3,    3.6,    4.2,    4.7], # B8
    [6.0,    np.inf, np.inf, np.inf, np.inf, 1.2,    1.0,    5.8,    50.4,   4.3,    3.6,    2.9,    2.2,    1.4,    0.7,    np.inf, 0.7,    1.4,    5.9,    5.2,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    np.inf, 6.2,    5.5,    4.8,    4.2,    3.6,    3.0,    2.3,    2.1,    2.0,    2.1,    2.5,    3.0,    3.5,    3.1,    3.2,    3.7,    4.1], # B9
    [6.7,    np.inf, np.inf, np.inf, np.inf, 1.7,    1.2,    6.5,    57.8,   5.1,    4.3,    3.6,    2.9,    2.2,    1.4,    0.7,    np.inf, 0.7,    6.6,    5.9,    5.2,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    np.inf, 6.9,    6.2,    5.5,    4.8,    4.2,    3.6,    2.8,    2.5,    2.1,    2.0,    2.1,    2.5,    3.0,    3.0,    3.0,    3.4,    3.5], # B10
    [7.4,    np.inf, np.inf, np.inf, np.inf, 2.4,    np.inf, 7.2,    64.9,   5.8,    5.1,    4.3,    3.6,    2.9,    2.2,    1.4,    0.7,    np.inf, 7.3,    6.6,    5.9,    5.2,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    np.inf, 7.6,    6.9,    6.2,    5.5,    4.8,    4.2,    3.4,    3.0,    2.5,    2.1,    2.0,    2.1,    2.5,    3.1,    2.9,    3.1,    3.0], # B11
    [1.1,    2.1,    2.5,    2.9,    3.5,    np.inf, 6.1,    1.0,    12.4,   1.8,    2.4,    3.1,    3.8,    4.5,    5.2,    5.9,    6.6,    7.3,    np.inf, 0.7,    1.5,    2.2,    2.9,    3.7,    4.4,    5.1,    5.9,    6.6,    7.3,    8.0,    np.inf, 1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    5.3,    6.0,    6.7,    7.5,    8.2,    8.9,    7.0,    7.7,    8.4,    9.5], # C1
    [1.4,    2.0,    2.1,    2.4,    2.9,    np.inf, 5.4,    1.2,    10.0,   1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    5.2,    5.9,    6.6,    0.7,    np.inf, 0.7,    1.5,    2.2,    2.9,    3.7,    4.4,    5.1,    5.9,    6.6,    7.3,    np.inf, 1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    5.3,    6.0,    6.7,    7.5,    8.2,    np.inf, np.inf, 7.7,    8.7], # C2
    [2.0,    2.1,    2.0,    2.1,    2.5,    4.1,    4.8,    1.8,    12.3,   1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    5.2,    5.9,    1.5,    0.7,    np.inf, 0.7,    1.5,    2.2,    2.9,    3.7,    4.4,    5.2,    5.9,    6.6,    np.inf, 1.8,    12.3,   1.0,    1.2,    1.8,    2.4,    3.0,    3.8,    4.5,    5.3,    6.0,    6.7,    7.5,    5.6,    6.3,    7.0,    8.0], # C3
    [2.6,    2.5,    2.1,    2.0,    2.1,    3.5,    4.1,    2.4,    17.6,   1.3,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    5.2,    2.2,    1.5,    0.7,    np.inf, 0.8,    1.5,    2.2,    2.9,    3.7,    4.4,    5.2,    5.9,    np.inf, 2.4,    1.8,    1.2,    1.0,    1.3,    1.8,    2.4,    3.1,    3.9,    4.6,    5.3,    6.0,    6.7,    np.inf, 5.6,    6.3,    7.3], # C4
    [3.3,    2.9,    2.5,    2.1,    2.0,    2.9,    3.5,    3.1,    24.0,   1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    2.9,    2.2,    1.5,    0.8,    np.inf, 0.7,    1.5,    2.2,    2.9,    3.7,    4.4,    6.1,    np.inf, 3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.7,    2.4,    3.1,    3.8,    4.6,    5.3,    6.0,    4.2,    4.9,    5.6,    6.5], # C5
    [4.0,    3.5,    3.0,    2.4,    2.1,    2.5,    3.0,    3.8,    30.7,   2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    3.7,    2.9,    2.2,    1.5,    0.7,    np.inf, 0.8,    1.5,    2.2,    2.9,    3.7,    4.4,    np.inf, 3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.1,    1.8,    2.4,    3.1,    3.8,    4.6,    5.3,    3.6,    4.2,    4.9,    5.8], # C6
    [4.8,    4.1,    3.5,    2.9,    np.inf, 2.1,    2.5,    4.5,    37.6,   3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    4.4,    3.7,    2.9,    2.2,    1.5,    0.8,    np.inf, 0.7,    1.5,    2.2,    2.9,    3.7,    np.inf, 4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    0.8,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    3.3,    3.5,    4.2,    4.4], # C7
    [5.5,    4.8,    4.1,    3.5,    np.inf, 2.0,    2.1,    5.2,    44.8,   3.8,    3.1,    2.4,    1.8,    1.3,    1.0,    1.2,    1.8,    2.4,    5.1,    4.4,    3.7,    2.9,    2.2,    1.5,    0.7,    np.inf, 0.7,    1.5,    2.2,    2.9,    np.inf, 5.3,    4.5,    3.8,    3.1,    2.4,    1.8,    1.1,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    2.5,    2.9,    3.6,    4.4], # C8
    [6.2,    5.4,    4.8,    4.1,    np.inf, 2.1,    2.0,    5.9,    51.9,   4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    5.9,    5.1,    4.4,    3.7,    2.9,    2.2,    1.5,    0.7,    np.inf, 0.7,    1.5,    2.2,    np.inf, 6.0,    5.3,    4.6,    3.8,    3.1,    2.4,    1.7,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    2.1,    2.4,    3.0,    3.7], # C9
    [6.9,    6.1,    5.4,    np.inf, np.inf, 2.5,    2.1,    6.6,    59.0,   5.2,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    6.6,    5.9,    5.2,    4.4,    3.7,    2.9,    2.2,    1.5,    0.7,    np.inf, 0.7,    1.5,    np.inf, 6.7,    6.0,    5.3,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    2.0,    2.0,    2.5,    3.0], # C10
    [7.6,    6.8,    np.inf, np.inf, np.inf, 2.9,    2.5,    7.3,    66.3,   5.9,    5.2,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    7.3,    6.6,    5.9,    5.2,    4.4,    3.7,    2.9,    2.2,    1.5,    0.7,    np.inf, 0.7,    np.inf, 7.5,    6.7,    6.0,    5.3,    4.6,    3.8,    3.1,    2.4,    1.8,    1.3,    1.0,    1.2,    1.8,    2.1,    1.9,    2.1,    2.4], # C11
    [8.3,    7.5,    np.inf, np.inf, np.inf, 3.5,    np.inf, 8.1,    73.4,   6.6,    5.9,    5.2,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    8.0,    7.3,    6.6,    5.9,    6.1,    4.4,    3.7,    2.9,    2.2,    1.5,    0.7,    np.inf, np.inf, 8.2,    7.5,    6.7,    6.0,    5.3,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    2.5,    2.0,    2.0,    1.8], # C12
    [np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, 1.0,    np.inf, np.inf, np.inf, 1.4], # C13
    [2.2,    3.1,    3.3,    3.7,    4.2,    5.9,    6.5,    2.0,    21.2,   2.5,    3.0,    3.6,    4.2,    4.8,    5.5,    6.2,    6.9,    7.6,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    5.3,    6.0,    6.7,    7.5,    8.2,    np.inf, np.inf, 0.7,    1.5,    2.2,    3.0,    np.inf, 4.5,    np.inf, np.inf, np.inf, 7.5,    8.2,    8.9,    np.inf, np.inf, np.inf, np.inf], # D1
    [2.4,    3.0,    3.1,    3.3,    3.7,    5.3,    5.9,    2.1,    20.0,   2.1,    2.5,    3.0,    3.5,    4.2,    4.8,    5.5,    6.2,    6.9,    1.2,    1.0,    12.3,   1.8,    2.4,    3.1,    3.8,    4.5,    5.3,    6.0,    6.7,    7.5,    np.inf, 0.7,    np.inf, 0.7,    1.5,    2.2,    3.0,    3.7,    np.inf, np.inf, np.inf, np.inf, 7.4,    8.2,    np.inf, np.inf, np.inf, np.inf], # D2
    [2.7,    3.1,    3.0,    3.1,    3.3,    4.7,    5.3,    2.5,    21.3,   2.0,    2.1,    2.5,    3.0,    3.6,    4.2,    4.8,    5.5,    6.2,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.6,    5.3,    6.0,    6.7,    np.inf, 1.5,    0.7,    np.inf, 0.7,    1.5,    2.2,    3.0,    np.inf, np.inf, np.inf, np.inf, np.inf, 7.4,    np.inf, np.inf, np.inf, np.inf], # D3
    [3.3,    3.3,    3.1,    3.0,    3.1,    4.2,    4.7,    3.0,    24.7,   2.2,    2.0,    2.1,    2.5,    3.0,    3.5,    4.2,    4.8,    5.5,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    5.3,    6.0,    np.inf, 2.2,    1.5,    0.7,    np.inf, 0.7,    np.inf, 2.3,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf], # D4
    [3.8,    3.7,    3.3,    3.1,    3.0,    3.7,    4.2,    3.5,    29.6,   2.5,    2.1,    2.0,    2.1,    2.5,    3.0,    3.6,    4.2,    4.8,    3.1,    2.4,    1.8,    1.3,    1.0,    1.2,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    np.inf, np.inf, 3.0,    2.2,    np.inf, np.inf, np.inf, 0.8,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf], # D5
    [4.5,    4.2,    3.7,    3.3,    3.1,    3.3,    3.7,    4.2,    35.5,   3.0,    2.5,    2.1,    2.0,    2.1,    2.4,    3.0,    3.6,    4.2,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    3.8,    4.5,    np.inf, np.inf, 3.0,    2.2,    np.inf, np.inf, np.inf, 0.8,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf], # D6
    [5.1,    4.6,    4.0,    3.5,    np.inf, 2.9,    3.1,    4.7,    40.8,   3.4,    2.8,    2.3,    1.9,    1.8,    1.9,    2.3,    2.8,    3.4,    4.5,    3.8,    3.0,    2.4,    1.7,    1.1,    0.8,    1.1,    1.7,    2.4,    3.1,    3.8,    np.inf, 4.5,    3.7,    3.0,    2.3,    1.5,    0.8,    np.inf, 0.8,    1.5,    2.2,    3.0,    3.7,    4.5,    2.6,    3.2,    3.9,    5.0], # D7
    [5.8,    5.3,    4.7,    4.2,    np.inf, 3.0,    3.1,    5.5,    48.3,   4.2,    3.6,    3.0,    2.5,    2.1,    2.0,    2.1,    2.5,    3.0,    5.3,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    3.1,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, 0.8,    np.inf, 0.8,    1.5,    2.3,    3.0,    3.7,    np.inf, 2.4,    3.2,    4.2], # D8
    [6.5,    5.9,    5.3,    4.7,    np.inf, 3.1,    3.0,    6.2,    55.1,   4.9,    4.2,    3.5,    3.0,    2.5,    2.1,    2.0,    2.1,    2.5,    6.0,    5.3,    4.5,    3.9,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    1.8,    2.4,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, 1.5,    0.8,    np.inf, 0.8,    1.5,    2.2,    3.0,    1.2,    1.7,    2.5,    3.5], # D9
    [7.2,    6.6,    5.9,    5.2,    np.inf, 3.3,    3.1,    6.9,    61.9,   5.5,    4.8,    4.2,    3.6,    3.0,    2.5,    2.1,    2.0,    2.1,    6.7,    6.0,    5.3,    4.6,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.3,    1.8,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, 2.2,    1.5,    0.8,    np.inf, 0.8,    1.5,    2.2,    1.0,    1.2,    1.8,    2.7], # D10
    [7.9,    7.2,    6.6,    5.9,    np.inf, 3.7,    3.3,    7.6,    69.0,   6.2,    5.5,    4.8,    4.2,    3.6,    3.0,    2.5,    2.1,    2.0,    7.5,    6.7,    6.0,    5.3,    4.6,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    1.2,    np.inf, 7.5,    np.inf, np.inf, np.inf, np.inf, np.inf, 3.0,    2.3,    1.5,    0.8,    np.inf, 0.7,    1.5,    1.3,    0.9,    1.2,    2.0], # D11
    [8.6,    7.9,    7.2,    np.inf, np.inf, 4.2,    3.7,    8.3,    75.9,   6.9,    6.2,    5.5,    4.8,    4.2,    3.6,    3.0,    2.5,    2.1,    8.2,    7.5,    6.7,    6.0,    5.3,    4.6,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    np.inf, 8.2,    7.4,    np.inf, np.inf, np.inf, np.inf, 3.7,    3.0,    2.2,    1.5,    0.7,    np.inf, 0.7,    1.8,    1.1,    1.0,    1.3], # D12
    [9.3,    8.6,    7.9,    np.inf, np.inf, 4.7,    np.inf, 9.0,    82.2,   7.6,    6.9,    6.2,    5.5,    4.8,    4.2,    3.5,    3.0,    2.5,    8.9,    8.2,    7.5,    6.7,    6.0,    5.3,    4.5,    3.8,    3.1,    2.4,    1.8,    1.2,    1.0,    8.9,    8.2,    7.4,    np.inf, np.inf, np.inf, 4.5,    3.7,    3.0,    2.2,    1.5,    0.7,    np.inf, 2.5,    1.7,    1.2,    0.6], # D13
    [7.5,    7.1,    6.5,    5.9,    np.inf, 4.3,    4.1,    7.3,    np.inf, 6.0,    5.3,    4.7,    4.2,    3.7,    3.3,    3.1,    3.0,    3.1,    7.0,    6.3,    5.6,    4.9,    4.2,    3.6,    3.3,    2.5,    2.1,    2.0,    2.1,    2.5,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, 2.6,    np.inf, 1.2,    1.0,    1.3,    1.8,    2.5,    np.inf, 0.8,    np.inf, 2.8], # E1
    [8.3,    7.7,    7.0,    6.4,    np.inf, 4.5,    4.2,    7.9,    72.5,   6.6,    5.9,    5.3,    4.7,    4.1,    3.6,    3.2,    3.0,    2.9,    7.7,    7.0,    6.3,    5.6,    4.9,    4.2,    3.5,    2.9,    2.4,    2.0,    1.9,    2.0,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, 3.2,    2.4,    1.7,    1.2,    0.9,    1.1,    1.7,    0.8,    np.inf, np.inf, 2.1], # E2
    [9.0,    8.4,    7.7,    7.1,    np.inf, 5.0,    4.6,    8.7,    79.5,   7.3,    6.6,    6.0,    5.4,    4.8,    4.2,    3.7,    3.4,    3.1,    8.4,    7.7,    7.0,    6.3,    5.6,    4.9,    4.2,    3.6,    3.0,    2.5,    2.1,    2.0,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, 3.9,    3.2,    2.5,    1.8,    1.2,    1.0,    1.2,    np.inf, np.inf, np.inf, 1.4], # E3
    [9.9,    9.1,    8.5,    np.inf, np.inf, 5.3,    np.inf, 9.6,    88.7,   8.1,    7.5,    6.7,    6.1,    5.4,    4.7,    4.1,    3.5,    3.0,    9.5,    8.7,    8.0,    7.3,    6.5,    5.8,    4.4,    4.4,    3.7,    3.0,    2.4,    1.8,    1.4,    np.inf, np.inf, np.inf, np.inf, np.inf, np.inf, 5.0,    4.2,    3.5,    2.7,    2.0,    1.3,    0.6,    2.8,    2.1,    1.4,    np.inf], # E
  ])
   # Vertexes
    vertexes = ['S', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9', 'B10', 'B11', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9', 'C10', 'C11', 'C12', 'C13', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9', 'D10', 'D11', 'D12', 'D13', 'E1', 'E2','E3', 'E']

    cost_matrix = pd.DataFrame(connections_cost, index=vertexes, columns=vertexes)

    # Define the handling costs
    handling_costs = {'S': 1, 'A1': 1, 'A2': 1, 'A3': 1, 'A4': 1, 'A5': 1, 'A6': 1, 'B1': 1, 'B2': 1, 'B3': 1, 'B4': 1, 'B5': 1, 'B6': 1, 'B7': 1, 'B8': 1, 'B9': 1, 'B10': 1, 'B11': 1, 'C1': 1, 'C2': 1, 'C3': 1, 'C4': 1, 'C5': 1, 'C6': 1, 'C7': 1, 'C8': 1, 'C9': 1, 'C10': 1, 'C11': 1, 'C12': 1, 'C13': 1, 'D1': 1, 'D2': 1, 'D3': 1, 'D4': 1, 'D5': 1, 'D6': 1, 'D7': 1, 'D8': 1, 'D9': 1, 'D10': 1, 'D12': 1, 'D12': 1, 'D13': 1, 'E1': 1, 'E2': 1, 'E3': 1, 'E': 1}

    # Origin
    origin = 'S'

    # Destination
    destination = 'E'
  #vertexes coordinates - for visualisation purposes (Optional)
    vertexes_coords = {
        'S':{'latitude': 44.09, 'longitude': 28.7},
        'A1':{'latitude': 45, 'longitude': 30},
        'A2':{'latitude': 45, 'longitude': 31},
        'A3':{'latitude': 45, 'longitude': 32},
        'A4':{'latitude': 45, 'longitude': 33},
        'A5':{'latitude': 45, 'longitude': 36},
        'A6':{'latitude': 45, 'longitude': 37},
        'B1':{'latitude': 44, 'longitude': 29},
        'B2':{'latitude': 44, 'longitude': 30},
        'B3':{'latitude': 44, 'longitude': 31},
        'B4':{'latitude': 44, 'longitude': 32},
        'B5':{'latitude': 44, 'longitude': 33},
        'B6':{'latitude': 44, 'longitude': 34},
        'B7':{'latitude': 44, 'longitude': 35},
        'B8':{'latitude': 44, 'longitude': 36},
        'B9':{'latitude': 44, 'longitude': 37},
        'B10':{'latitude': 44, 'longitude': 38},
        'B11':{'latitude': 44, 'longitude': 39},
        'C1':{'latitude': 43, 'longitude': 29},
        'C2':{'latitude': 43, 'longitude': 30},
        'C3':{'latitude': 43, 'longitude': 31},
        'C4':{'latitude': 43, 'longitude': 32},
        'C5':{'latitude': 43, 'longitude': 33},
        'C6':{'latitude': 43, 'longitude': 34},
        'C7':{'latitude': 43, 'longitude': 35},
        'C8':{'latitude': 43, 'longitude': 36},
        'C9':{'latitude': 43, 'longitude': 37},
        'C10':{'latitude': 43, 'longitude': 38},
        'C11':{'latitude': 43, 'longitude': 39},
        'C12':{'latitude': 43, 'longitude': 40},
        'C13':{'latitude': 43, 'longitude': 41},
        'D1':{'latitude': 42, 'longitude': 29},
        'D2':{'latitude': 42, 'longitude': 30},
        'D3':{'latitude': 42, 'longitude': 31},
        'D4':{'latitude': 42, 'longitude': 32},
        'D5':{'latitude': 42, 'longitude': 33},
        'D6':{'latitude': 42, 'longitude': 34},
        'D7':{'latitude': 42.2, 'longitude': 35},
        'D8':{'latitude': 42, 'longitude': 36},
        'D9':{'latitude': 42, 'longitude': 37},
        'D10':{'latitude': 42, 'longitude': 38},
        'D11':{'latitude': 42, 'longitude': 39},
        'D12':{'latitude': 42, 'longitude': 40},
        'D13':{'latitude': 42, 'longitude': 41},
        'E1':{'latitude': 41, 'longitude': 38},
        'E2':{'latitude': 41.1, 'longitude': 39},
        'E3':{'latitude': 41, 'longitude': 40},
        'E':{'latitude': 41.7, 'longitude': 41.65},
        }

    return vertexes, origin, destination, handling_costs, cost_matrix, vertexes_coords
def create_network_map(vertexes, cost_matrix, vertexes_coords):
    """Create a visual representation of the network"""

    # Calculate average latitude and longitude for the initial map center
    avg_lat = sum(coord['latitude'] for coord in vertexes_coords.values()) / len(vertexes_coords)
    avg_lon = sum(coord['longitude'] for coord in vertexes_coords.values()) / len(vertexes_coords)

    # Create a map centered around the average location
    map = folium.Map(location=[avg_lat, avg_lon], zoom_start=5)

    # Add markers for each vertex
    for vertex, coords in vertexes_coords.items():
        folium.Marker([coords['latitude'], coords['longitude']], popup=vertex).add_to(map)

    # Determine min and max costs for normalization
    min_cost = np.min(cost_matrix[cost_matrix != np.inf])
    max_cost = np.max(cost_matrix[cost_matrix != np.inf])

    # Function to normalize costs to a range for line widths
    def normalize_cost(cost, min_cost, max_cost, min_width=0.2, max_width=88.7):
        # Inverse normalization to make cheaper routes thicker
        return max_width - (cost - min_cost) * (max_width - min_width) / (max_cost - min_cost)

    line_color = '#69b8d6' # Color for the lines

    # Draw connections with varying line widths
    for i, vertex1 in enumerate(vertexes):
        for j, vertex2 in enumerate(vertexes):
            if i != j and cost_matrix.iloc[i, j] != np.inf:
                cost = cost_matrix.iloc[i, j]
                line_width = normalize_cost(cost, min_cost, max_cost)
                location1 = [vertexes_coords[vertex1]['latitude'], vertexes_coords[vertex1]['longitude']]
                location2 = [vertexes_coords[vertex2]['latitude'], vertexes_coords[vertex2]['longitude']]
                line = folium.PolyLine(locations=[location1, location2], weight=line_width, color=line_color)
                map.add_child(line)

    return map
def get_ga_config():
    """Get the configuration for the genetic algorithm"""
    population_size = 20 # Number of individuals in the population
    elitism_percentage = 0.2 # Percentage of the population to be selected for elitism
    tournament_size = 5 # Number of chromosomes to select for tournament
    max_generations = 100 # Number of generations to run the algorithm for
    max_stagnation = 20 # Number of generations to wait before terminating due to stagnation

    return population_size, elitism_percentage, tournament_size, max_generations, max_stagnation
def initialise_population(pop_size, vertexes, origin, destination):
    """Create a population of chromosomes"""
    population = []
    shortest_path_chromosome = {}
    longest_path_chromosome = {}

    # List all other vertexes besides the origin and destination
    connection_vertexes = [vertex for vertex in vertexes if vertex not in [origin, destination]]  # exclude origin and destination

    # Add a cromosome with the shortest path
    shortest_path_chromosome['route'] = [origin] + [destination]
    population.append(shortest_path_chromosome)

    # Add a chromosome with the longest path (going through all vertexes)
    longest_path_chromosome['route'] = [origin] + connection_vertexes + [destination]
    population.append(longest_path_chromosome)

    # Add chromosomes with random paths between origin and destination until we reach the total number of individuals in the population
    for _ in range(pop_size - 2):
        random_chromosome = {}
        # Randomly decide how many intermediate vertexes to include
        num_intermediate = random.randint(0, len(connection_vertexes) - 2)
        # Randomly select the intermediate vertexes
        intermediate_vertexes = random.sample(connection_vertexes, num_intermediate)
        # Build the chromosome
        random_chromosome['route'] = [origin] + intermediate_vertexes + [destination]
        # Add chromosome to population
        population.append(random_chromosome)

    return population
    def evaluate_and_sort_population(population, cost_matrix, handling_costs):
        """Evaluate the population and sort it in ascending order of cost"""
    for chromosome in population:
        if 'cost' not in chromosome.keys():
            total_cost = 0
            for i in range(len(chromosome['route'])-1):
                vertex1 = chromosome['route'][i]
                vertex2 = chromosome['route'][i + 1]
                total_cost += cost_matrix.loc[vertex1, vertex2] + handling_costs[vertex1]
            chromosome['cost'] = total_cost
    return sorted(population, key=lambda x: x['cost'])
    def tournament_selection(population, tournament_size):
        """Select two parents from the population using tournament selection"""
    selected_parents = []
    for _ in range(2): # Select two parents
        # Randomly select tournament_size chromosomes for the tournament
        tournament = random.sample(population, tournament_size)
        # Select the best chromosome from the tournament
        winner = min(tournament, key=lambda x: x['cost'])
        selected_parents.append(winner)
    return selected_parents
    def crossover(parent1, parent2, origin, destination):
        """Create two new chromosomes by applying crossover to two parent chromosomes"""
    route1 = copy.deepcopy(parent1['route'])
    route2 = copy.deepcopy(parent2['route'])

    #Proceed to crossover if both parents have more than two vertexes and if parents are different
    if min(len(route1), len(route2)) > 2 and route1 != route2:
        # If one of the parents has only 3 vertexes, then add the other parent's vertexes to the offspring (otherwise we end up with offsprings which are the same as the parents)
        if min(len(route1), len(route2)) == 3:
            # Randomly select a crossover point
            crossover_point = random.randint(1, min(len(route1), len(route2))-1)
            # Perform crossover
            offspring1_route = route1 + route2[crossover_point:]
            offspring2_route = route2 + route1[crossover_point:]

        else: 
            # Randomly select a crossover point (between 2 and the minimum length of the two routes -2, to maximise odds of having offsprings different from parents)
            crossover_point = random.randint(2, min(len(route1), len(route2)) - 2)

            # Perform crossover
            offspring1_route = route1[:crossover_point] + route2[crossover_point:]
            offspring2_route = route2[:crossover_point] + route1[crossover_point:]

        # Repair the offsprings routes to avoid repeating vertexes 
        offspring1_route = repair_route(offspring1_route, origin, destination)
        offspring2_route = repair_route(offspring2_route, origin, destination)

        # Create offsprings
        offspring1 = {"route": offspring1_route}
        offspring2 = {"route": offspring2_route}

        return offspring1, offspring2

    # If one or both parents have only one leg, return the parents since offsprings would be the same as parents
    else:
        return parent1, parent2


def repair_route(route, origin, destination):
    """Repair a route by ensuring it starts and ends at the origin and destination, respectively, and by removing repeated vertexes"""
    # Ensure first vertex is origin and last vertex is destination and remove intermediate vertexes if they are origin or destination
    if route[0] != origin:
        route[0] = origin
    if route[-1] != destination:
        route[-1] = destination
    route = [route[0]] + [vertex for vertex in route[1:-1] if vertex != origin and vertex != destination] + [route[-1]]

    # Remove repeated vertexes
    seen = set()
    repaired_route = [seen.add(vertex) or vertex for vertex in route if vertex not in seen] # adds vertex to seen if not already there and, in that case, adds vertex to fixed_route

    return repaired_route
    # Mutation Function
def mutation(chromosome, vertexes, origin, destination):
    """Create two new chromosomes by applying mutations to a chromosome"""
    route1 = copy.deepcopy(chromosome['route'])
    route2 = copy.deepcopy(chromosome['route'])

    # Ensure we only add vertexes that are not the origin, destination, or already in the route
    possible_vertexes_to_add = [vertex for vertex in vertexes if vertex not in chromosome['route']]

    # If chromosome has only 2 vertexes, create two new chromosomes by adding a vertex between the origin and destination (position 1):
    if len(chromosome['route']) == 2:
        route1.insert(1, random.choice(possible_vertexes_to_add))
        route2.insert(1, random.choice(possible_vertexes_to_add))

    # If chromosome has 3 or more vertexes, create a new chromosome by removing a vertex
    elif len(chromosome['route']) >= 3:
        route1.pop(random.randint(1, len(chromosome['route'])-1))

        # If chromosome has 3 vertexes, create a new chromosome by adding a vertex between the origin and destination (position 1):
        if len(chromosome['route']) == 3:
            route2.insert(1, random.choice(possible_vertexes_to_add))

        # If chromosome has 4 or more vertexes, create a new chromosome by swapping two vertexes
        elif len(chromosome['route']) >= 4:
            idx1, idx2 = random.sample(range(1, len(chromosome['route'])-1), 2)  # Get two distinct indices
            # Perform the swap
            route2[idx1], route2[idx2] = route2[idx2], route2[idx1]

    # Repair routes if necessary
    route1 = repair_route(route1, origin, destination)
    route2 = repair_route(route2, origin, destination)

    # Create offsprings
    mutated_chromosome1 = {"route": route1}
    mutated_chromosome2 = {"route": route2}

    return mutated_chromosome1, mutated_chromosome2
    def animate_best_routes(best_routes_per_generation, vertexes, cost_matrix, vertexes_coords):
        """Create an animation to show the best route evolving with generations"""
    # Generate the frames
    images_paths = []
    unique_best_routes = [] # to avoid repeated routes in best_routes_per_generation
    _ = [unique_best_routes.append(x) for x in best_routes_per_generation if x not in unique_best_routes]

    # Use this for a GIF with all best route solutions
    for frame, (route, cost) in enumerate(best_routes_per_generation):

    # # Use this, instead, for a GIF with only unique solutions
    # for frame, (route, cost) in enumerate(unique_best_routes):

        map = create_network_map(vertexes, cost_matrix, vertexes_coords)

        route_colour = '#004E6B' # Color for the route
        # Add the evolving route for this generation to the map
        route_coords = [[vertexes_coords[vertexes]['latitude'], vertexes_coords[vertexes]['longitude']] for vertexes in route]
        folium.PolyLine(route_coords, color=route_colour, weight=5, opacity=1).add_to(map)

        # Calculate average latitude and longitude for legend
        avg_lat = sum(coord['latitude'] for coord in vertexes_coords.values()) / len(vertexes_coords)
        avg_lon = sum(coord['longitude'] for coord in vertexes_coords.values()) / len(vertexes_coords)
        # Add a legend with the cost
        legend_html = f'''
            <div style="position: fixed; 
                        bottom: -250px; left: 220px; width: 150px; height: 90px; 
                        border:2px solid grey; z-index:9999; font-size:14px;
                        background-color:white; padding:10px;">
                <b>Cost: {cost}</b><br>
                Best solution in Generation {frame}
            </div>
        '''
        iframe = IFrame(legend_html, width=170, height=110)
        folium.Marker(location=[avg_lat, avg_lon], icon=folium.DivIcon(html=legend_html)).add_to(map)

        # Save the map as an HTML file for this frame
        html_path = f'data/output/animation/frame_{frame}.html'
        map.save(html_path)
        # Append image path to list
        image_path = f'data/output/animation/frame_{frame}.png'
        images_paths = images_paths + [image_path]

        convert_html_to_image(html_path, image_path)
        # Optionally delete html file
        os.remove(html_path)

    gif_path = f'data/output/animation/best_route_evolution_{best_routes_per_generation[0][0][0]}_{best_routes_per_generation[0][0][-1]}.gif'
    create_gif(images_paths, gif_path)

    # Optionally delete the image files after creating the GIF
    for image_path in images_paths:
        os.remove(image_path)

    return gif_path


def convert_html_to_image(html_path, image_path):
    """Convert an HTML file to an image and save it"""
    # Set up headless Chromium options
    chrome_options = Options()
    chrome_options.add_argument("--headless")
    chrome_options.add_argument("--disable-gpu")
    chrome_options.add_argument("--no-sandbox")
    chrome_options.binary_location = "/usr/bin/chromium"

    # Specify the path to chromedriver using Service
    service = Service(executable_path="/usr/bin/chromedriver")

    # Initialize the driver
    driver = webdriver.Chrome(service=service, options=chrome_options)

    # Load the HTML file
    absolute_html_path = os.path.abspath(html_path)
    driver.get("file://" + absolute_html_path)

    # # If image is blank, wait for the content to load
    # time.sleep(1)  # Adjust the time as needed

    # Set the size of the window to capture the entire page
    total_width = driver.execute_script("return document.body.offsetWidth")
    total_height = driver.execute_script("return document.body.scrollHeight")
    driver.set_window_size(total_width, total_height)

    # Take a screenshot and save it
    screenshot = driver.get_screenshot_as_png()
    driver.quit()

    # Convert screenshot to an image and save
    image = Image.open(io.BytesIO(screenshot))
    image.save(image_path)

def create_gif(images_paths, gif_path):
    """Create a GIF from a list of image paths"""
    images = [Image.open(image) for image in images_paths]

    # Set the duration for each frame (in milliseconds)
    default_duration = 300  # Duration for all frames except the last one
    durations = [default_duration] * (len(images) - 1)  # Apply default duration to all frames except the last
    durations.append(2000)  # Higher duration for the last frame so that end of loop in GIF is obvious

    images[0].save(gif_path, save_all=True, append_images=images[1:], duration=durations, loop=0)

def genetic_algorithm():
    """Run the genetic algorithm (GA)"""
    # Get data
    vertexes, origin, destination, handling_costs, cost_matrix, vertexes_coords = get_data()

    # Create visual representation of network (Optional)
    map = create_network_map(vertexes, cost_matrix, vertexes_coords)
    # Save the map to an HTML file
    map.save('data/output/animation/network_map.html')

    # Get GA configurations
    population_size, elitism_percentage, tournament_size, max_generations, max_stagnation = get_ga_config()

    # Initialise population
    population = initialise_population(population_size, vertexes, origin, destination)
    # Evaluate and sort the initial population
    population = evaluate_and_sort_population(population, cost_matrix, handling_costs)
    # Stagnation variables
    best_cost = float('inf')
    stagnation_counter = 0
    # Store best route for visualisation purposes
    best_routes_per_generation = [] 
    # Main GA loop
    for generation in range(max_generations):
        new_population = []

        # Apply elitism - select the best chromosomes from the population
        elite_chromosomes = population[:int(elitism_percentage * population_size)]
        new_population.extend(elite_chromosomes)

        while len(new_population) < population_size:
            # Apply tournament selection
            parent1, parent2 = tournament_selection(population, tournament_size)

            # Create new chromosomes applying crossover
            offspring1, offspring2 = crossover(parent1, parent2, origin, destination)
            
            # Create new chromosomes applying mutation to the new offsprings
            offspring3, offspring4 = mutation(offspring1, vertexes, origin, destination)

            # Add offsprings to new population
            new_population.extend([offspring1, offspring2, offspring3, offspring4])

        population = new_population
        population = evaluate_and_sort_population(population, cost_matrix, handling_costs)

        # Get best route
        best_chromosome = population[0]
        best_routes_per_generation.append((best_chromosome['route'], best_chromosome['cost']))

        # Check for stagnation
        current_best_cost = best_chromosome['cost']  # Population is sorted in ascending order of cost
        if current_best_cost < best_cost:
            best_cost = current_best_cost
            print(f'Generation {generation} best cost {best_cost}')
            stagnation_counter = 0  # Reset stagnation counter
        else:
            stagnation_counter += 1

        if stagnation_counter >= max_stagnation:
            print(f"Terminating due to stagnation at generation {generation}.")
            break

    if generation == max_generations - 1:
        print(f"Info: Terminating due to reaching maximum of {generation} generations.")

    print(f"Info: Best cost found: {best_cost}")
    print(f"Info: Best route found: {best_chromosome['route']}")
    
    # Create animation to show best route evolving with generations
    gif_path = animate_best_routes(best_routes_per_generation, vertexes, cost_matrix, vertexes_coords)

    print(f"Info: Animation of best route evolution is available in: {gif_path}")

    return

if __name__ == "__main__":
    genetic_algorithm()
